mod client;
mod server;
mod storage;
mod types;

use client::HttpRpcClient;
use jsonrpc_core::IoHandler;
use jsonrpc_http_server::ServerBuilder;
use jsonrpc_server_utils::cors::AccessControlAllowOrigin;
use jsonrpc_server_utils::hosts::DomainsValidation;

use ckb_hash::{blake2b_256, new_blake2b};
use ckb_jsonrpc_types as json_types;
use ckb_sdk::{build_signature, Address, AddressPayload, HumanCapacity, NetworkType};
use ckb_types::{
    bytes::{BufMut, Bytes, BytesMut},
    h256, packed,
    prelude::*,
    H160, H256,
};
use clap::{App, Arg, SubCommand};
use rocksdb::DB;
use serde::{Deserialize, Serialize};
use server::{Rpc, RpcImpl, TransactionReceipt};
use std::collections::HashMap;
use std::fs;
use std::process::Command;
use std::str::FromStr;
use std::sync::{Arc, Condvar, Mutex};
use std::thread;
use storage::{Indexer, Loader};
use tempfile::NamedTempFile;
use types::{CallKind, EoaAddress, Program, RunConfig, WitnessData, ONE_CKB, SECP256K1};

const ANYONE_CAN_PAY_CODE_HASH: H256 =
    h256!("0x8b10144daa110152e78dd002b44f429238cbbee5e62052205fdc6a1fc2c57a2a");

fn main() -> Result<(), String> {
    env_logger::init();

    let arg_ckb_url = Arg::with_name("url")
        .long("url")
        .takes_value(true)
        .required(true)
        .default_value("http://127.0.0.1:8114")
        .help("The ckb rpc url");
    let arg_privkey = Arg::with_name("privkey")
        .long("privkey")
        .short("k")
        .takes_value(true)
        .required(true)
        .validator(|input| {
            fs::File::open(input)
                .map(|_| ())
                .map_err(|err| err.to_string())
        })
        .help("The private key file (hex)");
    let matches = App::new("polyjuice")
        .subcommand(
            SubCommand::with_name("run")
                .about("Run the polyjuice server")
                .arg(
                    Arg::with_name("generator")
                        .long("generator")
                        .takes_value(true)
                        .required(true)
                        .validator(|input| fs::File::open(input).map(|_| ()).map_err(|err| err.to_string()))
                        .help("The generator riscv binary")
                )
                .arg(
                    Arg::with_name("config")
                        .long("config")
                        .takes_value(true)
                        .required(true)
                        .validator(|input| fs::File::open(input).map(|_| ()).map_err(|err| err.to_string()))
                        .help("The config (json)")
                )
                .arg(
                    Arg::with_name("db")
                        .long("db")
                        .takes_value(true)
                        .required(true)
                        .default_value("./data")
                        .help("Database directory")
                )
                .arg(
                    Arg::with_name("listen")
                        .long("listen")
                        .takes_value(true)
                        .required(true)
                        .default_value("127.0.0.1:8214")
                        .help("Polyjuice rpc server listen address")
                )
                .arg(arg_ckb_url.clone())
        )
        .subcommand(
            SubCommand::with_name("sign-tx")
                .about("Sign transaction generated by polyjuice")
                .arg(
                    Arg::with_name("tx-receipt")
                        .long("tx-receipt")
                        .short("t")
                        .takes_value(true)
                        .required(true)
                        .validator(|input| fs::File::open(input).map(|_| ()).map_err(|err| err.to_string()))
                        .help("The transaction receipt file (json)")
                )
                .arg(arg_privkey.clone())
                .arg(
                    Arg::with_name("output")
                        .long("output")
                        .short("o")
                        .takes_value(true)
                        .help("The output file path")
                )
                .arg(arg_ckb_url.clone())
        )
        .subcommand(
            SubCommand::with_name("new-eoa-account")
                .about("Create an EoA account")
                .arg(arg_privkey.clone())
                .arg(
                    Arg::with_name("balance")
                        .long("balance")
                        .takes_value(true)
                        .required(true)
                        .validator(|input| HumanCapacity::from_str(input.as_str()).map(|_| ()))
                        .help("The balance to target EoA account (unit: CKB, format: 123.335, need extra capacity to create the cell)")
                )
                .arg(arg_ckb_url.clone())
        )
        .subcommand(
            SubCommand::with_name("build-tx")
                .about("Build and serialize a eth transaction which will put into witness data")
                .arg(
                    Arg::with_name("call-kind")
                        .long("call-kind")
                        .takes_value(true)
                        .default_value("call")
                        .possible_values(&["create", "call"])
                        .help("The kind of the call")
                )
                .arg(Arg::with_name("static").long("static").help("Is static call"))
                .arg(
                    Arg::with_name("signature")
                        .long("signature")
                        .takes_value(true)
                        .validator(|input| parse_hex_binary(input.as_str()).map(|_| ()))
                        .help("The signature (65 bytes)")
                )
                .arg(
                    Arg::with_name("depth")
                        .long("depth")
                        .takes_value(true)
                        .validator(|input| input.parse::<u32>().map(|_| ()).map_err(|err| err.to_string()))
                        .default_value("0")
                        .help("The call depth"),
                )
                .arg(
                    Arg::with_name("sender")
                        .long("sender")
                        .takes_value(true)
                        .validator(|input| parse_h160(input.as_str()).map(|_| ()))
                        .default_value("0x1111111111111111111111111111111111111111")
                        .help("The sender of the message")
                )
                .arg(
                    Arg::with_name("destination")
                        .long("destination")
                        .takes_value(true)
                        .validator(|input| parse_h160(input.as_str()).map(|_| ()))
                        .default_value("0x2222222222222222222222222222222222222222")
                        .help("The destination of the message")
                )
                .arg(
                    Arg::with_name("code")
                        .long("code")
                        .takes_value(true)
                        .required(true)
                        .validator(|input| parse_hex_binary(input.as_str()).map(|_| ()))
                        .help("The code to create/call the contract, hex file path or hex string")
                )
                .arg(
                    Arg::with_name("input")
                        .long("input")
                        .takes_value(true)
                        .validator(|input| parse_hex_binary(input.as_str()).map(|_| ()))
                        .help("The input data to create/call the contract, hex file path or hex string")
                )
        ).get_matches();

    match matches.subcommand() {
        ("run", Some(m)) => {
            let generator = fs::read(m.value_of("generator").unwrap())
                .map(Bytes::from)
                .map_err(|err| err.to_string())?;
            let config_json: RunConfigJson = fs::read_to_string(m.value_of("config").unwrap())
                .map_err(|err| err.to_string())
                .and_then(|json_string| {
                    serde_json::from_str(json_string.as_str()).map_err(|err| err.to_string())
                })?;
            let run_config = RunConfig {
                generator,
                type_dep: config_json.type_dep.into(),
                type_script: config_json.type_script.into(),
                lock_dep: config_json.lock_dep.into(),
                lock_script: config_json.lock_script.into(),
                eoa_lock_dep: config_json.eoa_lock_dep.into(),
                eoa_lock_script: config_json.eoa_lock_script.into(),
            };
            let ckb_uri = m.value_of("url").unwrap();
            let db_dir = m.value_of("db").unwrap();
            let listen_addr = m.value_of("listen").unwrap();

            log::info!("Open database: {:?}", db_dir);
            let db = Arc::new(DB::open_default(db_dir).expect("rocksdb"));
            let loader = Arc::new(Loader::new(Arc::clone(&db), ckb_uri).expect("loader failure"));
            let mut indexer = Indexer::new(Arc::clone(&db), ckb_uri, run_config.clone());
            let _ = thread::spawn(move || indexer.index().expect("indexer faliure"));

            let mut io_handler = IoHandler::new();
            io_handler.extend_with(
                RpcImpl {
                    loader: Arc::clone(&loader),
                    run_config,
                }
                .to_delegate(),
            );

            let rpc_server = ServerBuilder::new(io_handler)
                .cors(DomainsValidation::AllowOnly(vec![
                    AccessControlAllowOrigin::Null,
                    AccessControlAllowOrigin::Any,
                ]))
                .threads(4)
                .max_request_body_size(10_485_760)
                .start_http(&listen_addr.parse().expect("parse listen address"))
                .expect("jsonrpc initialize");
            log::info!("RPC server listen on: {}", listen_addr);

            // Wait for exit
            let exit = Arc::new((Mutex::new(()), Condvar::new()));
            let e = Arc::clone(&exit);
            ctrlc::set_handler(move || {
                e.1.notify_all();
            })
            .expect("error setting Ctrl-C handler");
            let _guard = exit
                .1
                .wait(exit.0.lock().expect("locking"))
                .expect("waiting");
            rpc_server.close();
            log::info!("exiting...");
        }
        ("sign-tx", Some(m)) => {
            let mut tx_receipt: TransactionReceipt =
                fs::read_to_string(m.value_of("tx-receipt").unwrap())
                    .map_err(|err| err.to_string())
                    .and_then(|json_string| {
                        serde_json::from_str(json_string.as_str()).map_err(|err| err.to_string())
                    })?;
            // TODO: check the private key match the sender
            let privkey_path = m.value_of("privkey").unwrap();
            let privkey = fs::read_to_string(privkey_path)
                .map_err(|err| err.to_string())
                .and_then(|privkey| {
                    hex::decode(&privkey.trim().as_bytes()[0..64]).map_err(|err| err.to_string())
                })
                .and_then(|data| {
                    secp256k1::SecretKey::from_slice(data.as_slice()).map_err(|err| err.to_string())
                })?;
            let pubkey = secp256k1::PublicKey::from_secret_key(&SECP256K1, &privkey);
            let tx_origin_lock_arg =
                H160::from_slice(&blake2b_256(&pubkey.serialize()[..])[0..20]).unwrap();
            let ckb_uri = m.value_of("url").unwrap();

            println!("Building signature");
            let tx = packed::Transaction::from(tx_receipt.tx.clone());
            let tx_hash: H256 = tx.calc_tx_hash().unpack();
            let (message, entrance_witness_args, entrance_raw_witness) = {
                let mut entrance_witness = None;
                let mut unsigned_data = BytesMut::default();
                unsigned_data.put(tx_hash.as_bytes());
                let mut output_witnesses = Vec::new();
                for (idx, witness) in tx_receipt.tx.witnesses.iter().enumerate() {
                    let witness_args = packed::WitnessArgs::from_slice(witness.as_bytes())
                        .map_err(|err| err.to_string())?;
                    if let Some(raw_witness) = witness_args
                        .input_type()
                        .to_opt()
                        .map(|witness_data| witness_data.raw_data())
                    {
                        if idx == 0 {
                            entrance_witness = Some((witness_args, raw_witness.clone()));
                            let mut raw_witness = raw_witness.as_ref().to_vec();
                            // 4 bytes is for program length (u32)
                            raw_witness[4..4 + 65].copy_from_slice(&[0u8; 65][..]);
                            unsigned_data.put(&raw_witness[..]);
                        } else {
                            unsigned_data.put(raw_witness.as_ref());
                        }
                    } else if let Some(raw_witness) = witness_args
                        .output_type()
                        .to_opt()
                        .map(|witness_data| witness_data.raw_data())
                    {
                        output_witnesses.push((idx, witness_args, raw_witness));
                    }
                }
                for (idx, witness_args, raw_witness) in output_witnesses {
                    if idx == 0 {
                        entrance_witness = Some((witness_args, raw_witness.clone()));
                        let mut raw_witness = raw_witness.as_ref().to_vec();
                        // 4 bytes is for program length (u32)
                        raw_witness[4..4 + 65].copy_from_slice(&[0u8; 65][..]);
                        unsigned_data.put(&raw_witness[..]);
                    } else {
                        unsigned_data.put(raw_witness.as_ref());
                    }
                }

                let (entrance_witness_args, entrance_raw_witness) =
                    entrance_witness.ok_or_else(|| String::from("No entrance witness found"))?;
                let message = secp256k1::Message::from_slice(&blake2b_256(&unsigned_data)[..])
                    .map_err(|err| err.to_string())?;
                (message, entrance_witness_args, entrance_raw_witness)
            };
            let signature = SECP256K1.sign_recoverable(&message, &privkey);
            let (recov_id, data) = signature.serialize_compact();
            let mut signature_bytes = [0u8; 65];
            signature_bytes[0..64].copy_from_slice(&data[0..64]);
            signature_bytes[64] = recov_id.to_i32() as u8;

            println!("Rebuilding witness");
            let mut raw_witness = entrance_raw_witness.as_ref().to_vec();
            raw_witness[4..4 + 65].copy_from_slice(&signature_bytes[..]);
            let data = packed::BytesOpt::new_builder()
                .set(Some(Bytes::from(raw_witness).pack()))
                .build();
            let witness = if entrance_witness_args.output_type().to_opt().is_some() {
                entrance_witness_args.as_builder().output_type(data).build()
            } else {
                entrance_witness_args.as_builder().input_type(data).build()
            };

            tx_receipt.tx.witnesses[0] = json_types::JsonBytes::from_bytes(witness.as_bytes());
            while tx_receipt.tx.witnesses.len() < tx_receipt.tx.inputs.len() {
                tx_receipt.tx.witnesses.push(Default::default());
            }

            println!("Sign anyone can pay");
            let tx_view = packed::Transaction::from(tx_receipt.tx.clone()).into_view();
            let mut client = HttpRpcClient::new(ckb_uri.to_string());
            // {lock_arg => {type_hash => (input_index, input_capacity, output_capacity)}}
            let mut eoa_cells: HashMap<H160, HashMap<H256, (usize, u64, u64)>> = Default::default();
            for (idx, input) in tx_view.inputs().into_iter().enumerate() {
                let output: packed::CellOutput =
                    get_live_cell(&mut client, input.previous_output().into(), false)?.into();
                let lock_script = output.lock();
                let code_hash: H256 = lock_script.code_hash().unpack();
                if code_hash == ANYONE_CAN_PAY_CODE_HASH {
                    let type_hash: H256 = output
                        .type_()
                        .to_opt()
                        .expect("type id type script should exists")
                        .calc_script_hash()
                        .unpack();
                    let input_capacity: u64 = output.capacity().unpack();
                    let lock_arg =
                        H160::from_slice(lock_script.args().raw_data().as_ref()).unwrap();
                    let value = eoa_cells.entry(lock_arg).or_default();
                    if value.contains_key(&type_hash) {
                        return Err(format!("duplicated type script hash: {:x}", type_hash));
                    }
                    value.insert(type_hash, (idx, input_capacity, 0));
                }
            }
            for output in tx_view.outputs().into_iter() {
                let lock_script = output.lock();
                let code_hash: H256 = lock_script.code_hash().unpack();
                if code_hash == ANYONE_CAN_PAY_CODE_HASH {
                    let type_hash: H256 = output
                        .type_()
                        .to_opt()
                        .expect("type id type script should exists")
                        .calc_script_hash()
                        .unpack();
                    let output_capacity: u64 = output.capacity().unpack();
                    let lock_arg =
                        H160::from_slice(lock_script.args().raw_data().as_ref()).unwrap();
                    if let Some(value) = eoa_cells.get_mut(&lock_arg) {
                        if let Some(inner_value) = value.get_mut(&type_hash) {
                            inner_value.2 = output_capacity;
                        } else {
                            return Err(format!("type hash not found in output: {:x}", type_hash));
                        }
                    } else {
                        return Err(format!("lock arg not found in output: {:x}", lock_arg));
                    }
                }
            }
            for (lock_arg, type_scripts) in eoa_cells {
                let mut need_signature = false;
                let mut idxs = type_scripts
                    .values()
                    .map(|(idx, _, _)| *idx)
                    .collect::<Vec<_>>();
                idxs.sort();
                for (_, input_capacity, output_capacity) in type_scripts.values() {
                    if input_capacity > output_capacity {
                        need_signature = true;
                        break;
                    }
                }

                let lock_field = if need_signature {
                    if lock_arg != tx_origin_lock_arg {
                        return Err(format!("The only tx_origin need anyone can pay signature, current lock arg: {:x}", lock_arg));
                    }
                    let input_size = tx_view.inputs().len();
                    let witnesses: Vec<packed::Bytes> = tx_view.witnesses().into_iter().collect();
                    let signature = build_signature(
                        &tx_view,
                        input_size,
                        &idxs,
                        &witnesses,
                        None,
                        |message: &H256, _tx| {
                            let message =
                                secp256k1::Message::from_slice(message.as_bytes()).unwrap();
                            Ok(serialize_signature(
                                &SECP256K1.sign_recoverable(&message, &privkey),
                            ))
                        },
                    )?;

                    Some(signature)
                } else {
                    Some(Default::default())
                };

                let first_witness = &tx_receipt.tx.witnesses[idxs[0]];
                let init_witness = if first_witness.is_empty() {
                    packed::WitnessArgs::default()
                } else {
                    packed::WitnessArgs::from_slice(first_witness.as_bytes())
                        .map_err(|err| err.to_string())?
                };
                tx_receipt.tx.witnesses[idxs[0]] = json_types::JsonBytes::from_bytes(
                    init_witness
                        .as_builder()
                        .lock(lock_field.pack())
                        .build()
                        .as_bytes(),
                );
            }

            let tx_file = NamedTempFile::new().map_err(|err| err.to_string())?;
            let tx_path_str = tx_file.path().to_str().unwrap();
            println!(
                "[Command]: ckb-cli --url {} tx init --tx-file {}",
                ckb_uri, tx_path_str
            );
            let output = Command::new("ckb-cli")
                .args(&["--url", ckb_uri, "tx", "init", "--tx-file", tx_path_str])
                .output()
                .expect("Failed to execute command");
            if output.status.success() {
                println!("success!");
            } else {
                println!("[stdout]: {}", String::from_utf8_lossy(&output.stdout));
                println!("[stderr]: {}", String::from_utf8_lossy(&output.stderr));
            }

            let tx_body: serde_json::Value = serde_json::to_value(&tx_receipt.tx).unwrap();
            let cli_tx_content = fs::read_to_string(tx_path_str).unwrap();
            let mut cli_tx: serde_json::Value = serde_json::from_str(&cli_tx_content).unwrap();
            cli_tx["transaction"] = tx_body;
            let cli_tx_content = serde_json::to_string_pretty(&cli_tx).unwrap();
            if let Some(output) = m.value_of("output") {
                fs::write(output, cli_tx_content.as_bytes()).map_err(|err| err.to_string())?;
            } else {
                println!("{}", cli_tx_content);
            }
        }
        ("new-eoa-account", Some(m)) => {
            let balance_str = m.value_of("balance").unwrap();
            let ckb_uri = m.value_of("url").unwrap();
            let privkey_path = m.value_of("privkey").unwrap();
            let privkey = fs::read_to_string(privkey_path)
                .map_err(|err| err.to_string())
                .and_then(|privkey| {
                    hex::decode(&privkey.trim().as_bytes()[0..64]).map_err(|err| err.to_string())
                })
                .and_then(|data| {
                    secp256k1::SecretKey::from_slice(data.as_slice()).map_err(|err| err.to_string())
                })?;

            let balance = HumanCapacity::from_str(balance_str).unwrap().0;
            let capacity = balance + ONE_CKB * (8 + (32 + 1 + 32) + (32 + 1 + 20));
            let capacity_string = HumanCapacity(capacity).to_string();
            let mut client = HttpRpcClient::new(ckb_uri.to_string());
            let chain_info = client.get_blockchain_info()?;
            let network = NetworkType::from_raw_str(chain_info.chain.as_str())
                .ok_or_else(|| format!("Unexpected network type: {}", chain_info.chain))?;
            // FIXME: transfer to anyone-can-pay
            let pubkey = secp256k1::PublicKey::from_secret_key(&SECP256K1, &privkey);
            let lock_arg = H160::from_slice(&blake2b_256(&pubkey.serialize()[..])[0..20]).unwrap();
            println!("[lock-arg]: 0x{:x}", lock_arg);
            let address_payload = AddressPayload::new_full_data(
                ANYONE_CAN_PAY_CODE_HASH.pack(),
                Bytes::from(lock_arg.as_bytes().to_vec()),
            );
            let address_string = Address::new(network, address_payload).to_string();
            println!(
                "[Command]: ckb-cli wallet transfer --privkey-path {} --to-address {} --capacity {} --tx-fee 0.001 --type-id --skip-check-to-address",
                privkey_path,
                address_string,
                capacity_string,
            );
            let output = Command::new("ckb-cli")
                .args(&["--url", ckb_uri])
                .args(&["wallet", "transfer"])
                .args(&["--privkey-path", privkey_path])
                .args(&["--to-address", address_string.as_str()])
                .args(&["--capacity", capacity_string.as_str()])
                .args(&["--tx-fee", "0.001"])
                .args(&["--type-id", "--skip-check-to-address"])
                .output()
                .expect("Failed to execute command");
            if output.status.success() {
                println!(
                    "tx-hash: {}, output-index: 0",
                    String::from_utf8_lossy(&output.stdout).trim()
                );
            } else {
                println!("[stdout]: {}", String::from_utf8_lossy(&output.stdout));
                println!("[stderr]: {}", String::from_utf8_lossy(&output.stderr));
                return Err(String::from("failed"));
            }
            let tx_hash_string = String::from_utf8_lossy(&output.stdout)
                .trim()
                .chars()
                .skip(2)
                .collect::<String>();
            let tx_hash = H256::from_str(tx_hash_string.as_str()).unwrap();
            let tx_with_status = client.get_transaction(tx_hash)?.unwrap();
            let output = tx_with_status.transaction.inner.outputs[0].clone();
            let type_args = output.type_.unwrap().args;
            let lock_args = output.lock.args;
            let mut blake2b = new_blake2b();
            println!("[type_args]: {}", hex::encode(type_args.as_bytes()));
            println!("[lock_args]: {}", hex::encode(lock_args.as_bytes()));
            blake2b.update(type_args.as_bytes());
            blake2b.update(lock_args.as_bytes());
            let mut ret = [0u8; 32];
            blake2b.finalize(&mut ret);
            println!("0x{}", hex::encode(&ret[0..20]));
        }
        ("build-tx", Some(m)) => {
            let signature = m
                .value_of("signature")
                .map(|input| {
                    let data = parse_hex_binary(input)?;
                    if data.len() != 65 {
                        return Err(format!("Invalid data length for signature: {}", data.len()));
                    }
                    let mut target = [0u8; 65];
                    target.copy_from_slice(data.as_ref());
                    Ok(Bytes::from(target.to_vec()))
                })
                .transpose()?
                .unwrap_or_else(|| Bytes::from([0u8; 65].to_vec()));
            let kind: CallKind = m
                .value_of("call-kind")
                .map(|input| serde_json::from_str(format!("\"{}\"", input).as_str()).unwrap())
                .unwrap();
            let flags: u32 = if m.is_present("static") { 1 } else { 0 };
            let depth: u32 = m.value_of("depth").unwrap().parse::<u32>().unwrap();
            let sender = parse_h160(m.value_of("sender").unwrap()).unwrap();
            let destination = parse_h160(m.value_of("destination").unwrap()).unwrap();
            let code = parse_hex_binary(m.value_of("code").unwrap())
                .map(Bytes::from)
                .unwrap();
            let input = parse_hex_binary(m.value_of("input").unwrap_or(""))
                .map(Bytes::from)
                .unwrap();
            let program = Program {
                kind,
                flags,
                depth,
                tx_origin: EoaAddress(sender.clone()),
                sender,
                destination,
                value: 0,
                code,
                input,
            };
            let mut witness_data = WitnessData::new(program);
            witness_data.signature = signature;
            let program_data = witness_data.program_data();
            println!(
                "[length]: {}",
                hex::encode(&(program_data.len() as u32).to_le_bytes()[..])
            );
            println!("[binary]: {}", hex::encode(program_data.as_ref()));
        }
        _ => println!("{}", matches.usage()),
    }
    Ok(())
}

pub fn get_live_cell(
    client: &mut HttpRpcClient,
    out_point: json_types::OutPoint,
    with_data: bool,
) -> Result<json_types::CellOutput, String> {
    let cell = client.get_live_cell(out_point.clone(), with_data)?;
    if cell.status != "live" {
        return Err(format!(
            "Invalid cell status: {}, out_point: {:?}",
            cell.status, out_point
        ));
    }
    let cell_status = cell.status.clone();
    cell.cell.map(|cell| cell.output).ok_or_else(|| {
        format!(
            "Invalid input cell, status: {}, out_point: {:?}",
            cell_status, out_point
        )
    })
}

pub fn serialize_signature(signature: &secp256k1::recovery::RecoverableSignature) -> [u8; 65] {
    let (recov_id, data) = signature.serialize_compact();
    let mut signature_bytes = [0u8; 65];
    signature_bytes[0..64].copy_from_slice(&data[0..64]);
    signature_bytes[64] = recov_id.to_i32() as u8;
    signature_bytes
}

fn parse_h160(input: &str) -> Result<H160, String> {
    serde_json::from_str(format!("\"{}\"", input).as_str()).map_err(|err| err.to_string())
}

fn parse_hex_binary(input: &str) -> Result<Vec<u8>, String> {
    hex::decode(input)
        .map_err(|err| err.to_string())
        .or_else(|_err| {
            let content = fs::read_to_string(input).map_err(|err| err.to_string())?;
            hex::decode(&content).map_err(|err| err.to_string())
        })
}

// Can deploy those scripts by:
//     ckb-cli wallet transfer --data-path xxx
#[derive(Debug, Serialize, Deserialize)]
pub struct RunConfigJson {
    // Type script (Validator)
    pub type_dep: json_types::CellDep,
    pub type_script: json_types::Script,
    // Lock script for contract (default always success)
    pub lock_dep: json_types::CellDep,
    pub lock_script: json_types::Script,
    // Lock script for EoA account
    pub eoa_lock_dep: json_types::CellDep,
    pub eoa_lock_script: json_types::Script,
}
